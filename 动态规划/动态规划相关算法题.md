---
title: 动态规划相关算法题
excerpt: 对动态规划相关算法题的总结
categories:
- java算法
tags:
- 习题
---

### 1.1、[斐波那契数列](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```
public class T7 {
    public int Fibonacci(int n) {
        // 条件
        if (n <= 1) return n;
       	// 可以用自底向上的方法
        int pre2 = 0, pre1 = 1;
        int f = 0;
        for (int i = 2; i <= n; i++) {
            f = pre2 + pre1; // 如果动态规划，这个就是dp的公式
            pre2 = pre1;
            pre1 = f;
        }
        return f;
    }
}
```

### 1.2、[跳台阶](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```
public class T8 {
    public int JumpFloor(int target) {
        // 条件
        if (target <= 2) return target;
      	// 自底向上的方法
        int pre2 = 1, pre1 = 2;
        int sum = 0;
        for (int i = 3; i <= target; i++) {
            sum = pre2 + pre1; // 一样的道理， 和上面那道题的初始值不一样
            pre2 = pre1;
            pre1 = sum;
        }
        return sum;
    }
}
```

### 1.3、[矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```
public class T10 {
    public int RectCover(int target) {
        // 条件
        if (target <= 2) return target;
      	// 自底向上
        int pre2 = 1, pre1 = 2;
        int sum = 0;
        for (int i = 3; i <= target; i++) {
            sum = pre2 + pre1; // 同理呀
            pre2 = pre1;
            pre1 = sum;
        }
        return sum;
    }
}
```

### 1.4、[变态跳台阶](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```
public int JumpFloorII(int target) {
    int[] dp = new int[target];
    Arrays.fill(dp, 1);
    // 注意起始位置
    for (int i = 1; i < target; i++)
    // 开始跳
        for (int j = 0; j < i; j++)
        // 注意dp[i] 累计dp[j]
            dp[i] += dp[j];
    return dp[target - 1];
}
```

### 2. 最大子序和(1385)

https://leetcode-cn.com/problems/maximum-subarray/

```
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        // 注意两个变量的初始化
        int preSum = nums[0];
        int maxSum = preSum;
        // 注意从1开始
        for (int i = 1; i < nums.length; i++) {
            // 注意这个条件
            preSum = preSum > 0 ? preSum + nums[i] : nums[i];
            maxSum = Math.max(maxSum, preSum);
        }
        return maxSum;
    }
}
```

### 3.1、[股票的最大利润](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china)

```
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return -1;
        int min = prices[0];
        int max = 0;
        // 从1开始
        for (int i = 1; i < prices.length; i++) {
            // 注意保持最小
            min = prices[i] < min ? prices[i] : min;
            max = Math.max(max, prices[i] - min);
        }
        return max;
    }
}
```

### 3.2 买卖股票的最佳时机 II

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

```
class Solution {
    public int maxProfit(int[] prices) {
        // 贪心：只要我当前数比前一个数大， 就xxx
        int profit = 0;
        // 从1开始，因为下面的if
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) 
                profit += prices[i]- prices[i - 1];
        }
        return profit;
    }
}
```

### 3.3 买卖股票的最佳时机含手续费

状态机

```
class Solution {
    public int maxProfit(int[] prices, int fee) {
        if (prices == null || prices.length == 0)
            return 0;
            int buy = Integer.MIN_VALUE; // 购买股票后的收益，开始购买第一支股票后肯定是负数
            int sell = 0; // 售卖第一次股票后
            for (int i = 0; i < prices.length; i++){
                buy = Math.max(buy, sell - prices[i]);
                sell = Math.max(sell, buy + prices[i] - fee); //手续费在交易完成时一次性扣除
            }   
            return sell;
    }
}
```

### 4. 打家劫舍

https://leetcode-cn.com/problems/house-robber/description/

```
class Solution {
    public int rob(int[] nums) {
        int pre2 = 0, pre1 = 0;
        for (int i = 0; i < nums.length; i++) {
            // 注意这个状态转移，毕竟题目是隔着偷
            int cur = Math.max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
```

### 5. 打家劫舍 II

https://leetcode-cn.com/problems/house-robber-ii/description/

```
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int n = nums.length;
        if (n == 1) return nums[0];
        // 注意0-n-2 个 1 -n-1
        return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
    }

    private int rob(int[] nums, int first, int last) {
        int pre2 = 0, pre1 = 0;
        for (int i = first; i <= last; i++) {
            int cur = Math.max(pre1, pre2 + nums[i]);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
```

### 6、[剪绳子](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&tqId=33257&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```
// 动态规划
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    // 一厘米，没法切，所以从2
    for (int i = 2; i <= n; i++)
    // 切从1cm开始
        for (int j = 1; j < i; j++)
        //  注意这个状态转移
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```

### 7、[礼物的最大值](https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab)

```
public int getMost(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i < n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}
```

### 8. 最小路径和

https://leetcode-cn.com/problems/minimum-path-sum/description/

```
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) return 0;
        int m = grid.length, n = grid[0].length;
        // 优化过后的dp
        int[] dp = new int[n];
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j++) {
                if (j == 0)  // 注意
                    dp[j] = dp[j];
                else if (i == 0) // 注意
                    dp[j] = dp[j - 1];
                else // 注意
                    dp[j] = Math.min(dp[j], dp[j - 1]);
                // 别忘了
                dp[j] += grid[i][j];
            }
        }
        return dp[n-1];
    }
}
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        // 第一列
        for (int i = 1; i < m; i++){
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        // 第一行
        for (int j = 1; j < n; j++){
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++){
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
        
    }
}
```

### 9. 不同路径

https://leetcode-cn.com/problems/unique-paths/description/

```
class Solution {
    public int uniquePaths(int m, int n) {
        // 优化过后了
        int[] dp = new int[n];
        // 注意
        Arrays.fill(dp, 1);
        // 注意起始位置
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 累加
                dp[j] += dp[j - 1];
            }
        }
        return dp[n -1];
    }
}
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0)
                    dp[i][j] = 1;
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];        
    }
}
```

### 9.2 不同路径 II

https://leetcode-cn.com/problems/unique-paths-ii/

```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        // 因为if
        int[] dp = new int[n + 1];
        dp[1] = 1; // 注意初始值
        // 起始位置
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 别忘了条件
                if (obstacleGrid[i - 1][j - 1] == 1) 
                    dp[j] = 0;
                else 
                    dp[j] += dp[j - 1];
            }
        }
        return dp[n];
    }
}
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int [][] dp = new int[m+1][n+1];
        // 第一行 和 其他行的区别在于没有来自上边的路径 但是 起点到起点 算一条路径 所以这样初始化
        dp[0][1] = 1;
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(obstacleGrid[i-1][j-1] == 1) {
                    // 障碍 不可达 路径数量为0
                    dp[i][j] = 0;
                }
                else {
                    // 左 + 上
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m][n];
    }
}
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (obstacleGrid[i][j] == 1)
                    continue;
                if (i == 0 && j == 0)
                    continue;
                if(i == 0)
                    dp[i][j] = dp[i][j - 1];
                else if (j == 0)
                    dp[i][j] = dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

### 9.3 最大正方形

https://leetcode-cn.com/problems/maximal-square/

```
class Solution {
    public int maximalSquare(char[][] matrix) {
        /**
        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为: 
        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
        **/
        if (matrix == null ||  matrix.length == 0 || matrix[0].length == 0) return 0;
        int m = matrix.length;
        int n = matrix[0].length;
        int max = 0;
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++){
                if (matrix[i-1][j-1] == '1') {
                    // 左， 上，左上
                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        return max * max;
    }
}
```

### 10. 解码方法

https://leetcode-cn.com/problems/decode-ways/description/

```
class Solution {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1; // 初始值
        // 注意第一个元素是0？
        dp[1] = s.charAt(0) == '0' ? 0 : 1;
        // 注意起始位置，
        for (int i = 2; i <= n; i++) {
            // substring 用的很骚
            int one = Integer.valueOf(s.substring(i - 1, i));
            if (one != 0) {
                dp[i] += dp[i - 1];
            }
            // 注意这个判断
            if (s.charAt(i - 2) == '0') continue;
            int two = Integer.valueOf(s.substring(i - 2, i));
            if (two <= 26) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
}
```

### 11. 最长上升子序列

https://leetcode-cn.com/problems/longest-increasing-subsequence/description/

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        // 注意这个初始化
        Arrays.fill(dp, 1);
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    // 注意if
                    dp[i] = Math.max(dp[i], dp[j] + 1); // 关键这里，
                }
            }
        }
        // 找最大
        return Arrays.stream(dp).max().orElse(0);
    }
}
```

### 12. 最长公共子序列

https://leetcode-cn.com/problems/longest-common-subsequence/

```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n1 = text1.length(), n2 = text2.length();
        int[][] dp = new int[n1 + 1][n2 + 1];
        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n1][n2];
    }
}
```

[参考](https://kanarien.cn/2019/03/24/动态规划：01背包、完全背包、多重背包/)

### 15. 编辑距离

https://leetcode-cn.com/problems/edit-distance/description/

```
class Solution {
    public int minDistance(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i <= n; i++) {
            dp[0][i] = i;
        }
        // 这dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
                }
            }
        }
        return dp[m][n];
    }

}
```