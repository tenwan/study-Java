## 翻倍

考点在计算结果中可能出现超过int类型的数

>给定数字 A 和 B以及系数 p和 q。
>每次操作可以将 A变成 A+ p或者将 p变成 p* q。
>返回最少变化次数使得 B<= A
>
>```
>输入:
>A = 2
>B = 10
>p = 1
>q = 2
>输出: 4
>解释：通过三次变换之后，p = 8, 然后 A + p = 10，所以最终返回4.
>示例 2:
>输入:
>A = 2
>B = 13
>p = 8
>q = 4
>输出: 2
>解释：通过一次变换之后，p = 32, 然后 A + p = 34，所以最终返回2.
>```

```
public class Solution { 
    public int DoubleChange(int A, int B, int p, int q) {
        int n =0;
        long res = 0;  //结果可能超出int类型
        Long pc = new Long(p);
        while(res<B){
          res= A+pc;
          if(res<B){
            pc = pc*q;  //这里p的乘积结果也可能超出int，重改为long类型
            n++;
          }else{
            n++;
            break;
          }
        }
        return n;
    }
}
```

## 高楼大厦

>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行，楼高用arr表示。
>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？
>
>```
>输入:[5,3,8,3,2,5]
>输出:[3,3,5,4,4,4]
>解释:
>当小Q处于位置0时，他能看到位置0，1，2的3栋高楼。
>当小Q位于位置1时，他能看到位置0，1，2的3栋高楼。
>当小Q处于位置2时，他可以向前看到位置0，1处的楼，向后看到位置3,5处的楼，加上第3栋楼，共可看到5栋楼。
>当小Q处于位置3时，他能看到位置2，3，4，5的4栋高楼。
>当小Q处于位置4时，他能看到位置2，3，4，5的4栋高楼。
>当小Q处于位置5时，他能看到位置2，3，4，5的4栋高楼。
>```

```
public class Solution {

    // Input:  5,3,8,3,2,5]
    // Output:[3,3,5,4,4,4]
    // left||  8 3 2 5
    // right|| 5 2         
    // 单调递减 
    // result  1 2 3 2 3 4 

    public int[] tallBuilding(int[] input) {
        if (input == null || input.length == 0) {
            return new int[0];
        }
        int n = input.length;
        int[] result = new int[n];
        // 每个位置都能看到自己，至少为1
        Arrays.fill(result, 1);

        // 计算每个位置能看到的左侧楼的数目
        // count how many building in its left, 
        Deque<Integer> left = new ArrayDeque<>();  //双端队列
        for (int i = 0; i < n; i++) {
            result[i] += left.size();
            while (!left.isEmpty() && input[i] >= input[left.peekFirst()]) {
                left.pollFirst();
            }
            left.offerFirst(i);
        }
    
        // 计算每个位置能看到的右侧楼的数目
        Deque<Integer> right = new ArrayDeque<>();
        for (int i = n - 1; i >= 0; i--) {
            result[i] += right.size();
            while (!right.isEmpty() && input[i] >= input[right.peekFirst()]) {
                right.pollFirst();
            }
            right.offerFirst(i);
        }
        
        return result;
    }
}
```